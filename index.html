<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>KALAF SOFT - Sistema Check List de Paquetes</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìã</text></svg>">

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

<style>
:root {
--primary-color: #1e3a8a;
--primary-light: #3b82f6;
--secondary-color: #059669;
--secondary-light: #10b981;
--accent-color: #dc2626;
--accent-light: #ef4444;
--warning-color: #d97706;
--warning-light: #f59e0b;
--dark-color: #1f2937;
--light-color: #f8fafc;
--border-radius: 12px;
--shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
--shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
--transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
color: var(--dark-color);
line-height: 1.6;
}

.app-container {
min-height: 100vh;
display: flex;
flex-direction: column;
}

.app-header {
background: linear-gradient(135deg, var(--primary-color) 0%, var(--primary-light) 100%);
color: white;
padding: 1rem 2rem;
box-shadow: var(--shadow-lg);
position: relative;
}

.version {
position: absolute;
top: 10px;
right: 20px;
background: rgba(255, 255, 255, 0.2);
padding: 4px 8px;
border-radius: 4px;
font-size: 0.8rem;
font-weight: 500;
}

.connection-status {
position: absolute;
top: 10px;
left: 20px;
width: 12px;
height: 12px;
background: var(--secondary-light);
border-radius: 50%;
box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
}

.connection-status.offline {
background: var(--accent-light);
box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
}

.logo-section {
display: flex;
align-items: center;
gap: 1rem;
margin-top: 1rem;
}

.logo {
font-size: 3rem;
line-height: 1;
}

.company-info h1 {
font-size: 2rem;
font-weight: 700;
margin-bottom: 0.25rem;
}

.company-info p {
font-size: 1.1rem;
opacity: 0.9;
font-weight: 300;
}

.main-content {
flex: 1;
padding: 2rem;
max-width: 1200px;
margin: 0 auto;
width: 100%;
}

.card {
background: white;
border-radius: var(--border-radius);
box-shadow: var(--shadow);
margin-bottom: 2rem;
overflow: hidden;
border: 1px solid rgba(0, 0, 0, 0.05);
}

.card-header {
background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
padding: 1rem 1.5rem;
border-bottom: 1px solid #e2e8f0;
font-weight: 600;
font-size: 1.1rem;
display: flex;
align-items: center;
gap: 0.5rem;
color: var(--dark-color);
}

.card-body {
padding: 1.5rem;
}

.alert {
padding: 1rem 1.5rem;
margin-bottom: 1rem;
border-radius: var(--border-radius);
display: none;
font-weight: 500;
}

.alert-success {
background: #d1fae5;
color: #065f46;
border: 1px solid #a7f3d0;
}

.alert-error {
background: #fee2e2;
color: #991b1b;
border: 1px solid #fecaca;
}

.alert-warning {
background: #fef3c7;
color: #92400e;
border: 1px solid #fde68a;
}

.file-input-wrapper {
position: relative;
margin-bottom: 1rem;
}

.file-input {
position: absolute;
opacity: 0;
width: 0;
height: 0;
}

.file-input-label {
display: inline-flex;
align-items: center;
gap: 0.5rem;
padding: 0.75rem 1.5rem;
background: var(--primary-color);
color: white;
border-radius: var(--border-radius);
cursor: pointer;
font-weight: 500;
transition: var(--transition);
box-shadow: var(--shadow);
}

.file-input-label:hover {
background: var(--primary-light);
transform: translateY(-1px);
box-shadow: var(--shadow-lg);
}

.file-input-label.has-file {
background: var(--secondary-color);
}

.btn {
display: inline-flex;
align-items: center;
gap: 0.5rem;
padding: 0.75rem 1.5rem;
border: none;
border-radius: var(--border-radius);
font-weight: 500;
cursor: pointer;
transition: var(--transition);
font-size: 1rem;
box-shadow: var(--shadow);
}

.btn:disabled {
opacity: 0.5;
cursor: not-allowed;
transform: none !important;
}

.btn:hover:not(:disabled) {
transform: translateY(-1px);
box-shadow: var(--shadow-lg);
}

.btn-danger {
background: var(--accent-color);
color: white;
}

.btn-danger:hover:not(:disabled) {
background: var(--accent-light);
}

.btn-success {
background: var(--secondary-color);
color: white;
}

.btn-success:hover:not(:disabled) {
background: var(--secondary-light);
}

.btn-warning {
background: var(--warning-color);
color: white;
}

.btn-warning:hover:not(:disabled) {
background: var(--warning-light);
}

/* NUEVOS CONTROLES DE C√ÅMARA */
.camera-controls {
display: flex;
gap: 1rem;
margin-bottom: 1rem;
flex-wrap: wrap;
align-items: center;
}

.brightness-control, .contrast-control {
display: flex;
align-items: center;
gap: 0.5rem;
}

.brightness-control label, .contrast-control label {
font-size: 0.9rem;
font-weight: 500;
min-width: 80px;
}

.brightness-slider, .contrast-slider {
width: 150px;
height: 6px;
border-radius: 3px;
background: #e5e7eb;
outline: none;
-webkit-appearance: none;
}

.brightness-slider::-webkit-slider-thumb, .contrast-slider::-webkit-slider-thumb {
appearance: none;
width: 20px;
height: 20px;
border-radius: 50%;
background: var(--primary-color);
cursor: pointer;
box-shadow: var(--shadow);
}

.brightness-slider::-moz-range-thumb, .contrast-slider::-moz-range-thumb {
width: 20px;
height: 20px;
border-radius: 50%;
background: var(--primary-color);
cursor: pointer;
border: none;
box-shadow: var(--shadow);
}

.torch-toggle {
padding: 0.5rem 1rem;
font-size: 0.9rem;
}

.detection-info {
background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
border: 1px solid #bfdbfe;
border-radius: var(--border-radius);
padding: 1rem;
margin-bottom: 1rem;
display: none;
}

.detection-stats {
display: flex;
gap: 1rem;
font-size: 0.9rem;
}

.stat-item {
display: flex;
flex-direction: column;
align-items: center;
}

.stat-value {
font-weight: 700;
font-size: 1.2rem;
color: var(--primary-color);
}

.stat-label {
color: #6b7280;
font-size: 0.8rem;
}

.metrics-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
gap: 1rem;
margin-bottom: 2rem;
}

.metric-card {
background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
padding: 1.5rem;
border-radius: var(--border-radius);
text-align: center;
border: 2px solid transparent;
transition: var(--transition);
}

.metric-card.total {
border-color: var(--primary-light);
background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
}

.metric-card.success {
border-color: var(--secondary-light);
background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
}

.metric-card.pending {
border-color: var(--warning-light);
background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
}

.metric-value {
font-size: 2.5rem;
font-weight: 700;
color: var(--dark-color);
line-height: 1;
}

.metric-label {
font-size: 0.9rem;
color: #6b7280;
font-weight: 500;
margin-top: 0.5rem;
}

.progress-container {
margin-top: 1rem;
}

.progress-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 0.5rem;
}

.progress-label {
font-weight: 600;
color: var(--dark-color);
}

.progress-percentage {
font-weight: 700;
color: var(--primary-color);
}

.progress-bar {
background: #e5e7eb;
height: 12px;
border-radius: 6px;
overflow: hidden;
box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
}

.progress-fill {
background: linear-gradient(90deg, var(--primary-color) 0%, var(--primary-light) 100%);
height: 100%;
width: 0%;
transition: width 0.5s ease;
box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.camera-container {
position: relative;
background: #000;
border-radius: var(--border-radius);
overflow: hidden;
aspect-ratio: 16/9;
max-height: 400px;
}

.camera-placeholder {
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
height: 100%;
color: #9ca3af;
font-size: 1.1rem;
}

.camera-placeholder i {
font-size: 3rem;
margin-bottom: 1rem;
opacity: 0.5;
}

.camera-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 10;
}

#scanner_canvas {
position: absolute;
top: 0;
left: 0;
width: 100% !important;
height: 100% !important;
}

/* FILTROS DE IMAGEN MEJORADOS */
.camera-container video {
filter: brightness(var(--camera-brightness, 1)) contrast(var(--camera-contrast, 1));
transition: filter 0.3s ease;
}

.camera-container.low-light video {
filter: brightness(1.4) contrast(1.6) saturate(0.8);
}

.camera-container.enhanced video {
filter: brightness(1.2) contrast(1.4) saturate(1.1) hue-rotate(5deg);
}

.fardos-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
gap: 1rem;
max-height: 400px;
overflow-y: auto;
}

.fardo-item {
background: white;
border: 2px solid #e5e7eb;
border-radius: var(--border-radius);
padding: 1rem;
text-align: center;
font-weight: 600;
transition: var(--transition);
cursor: pointer;
}

.fardo-item:hover {
border-color: var(--primary-light);
transform: translateY(-2px);
box-shadow: var(--shadow);
}

.fardo-item.completed {
background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
border-color: var(--secondary-light);
color: var(--secondary-color);
}

.app-footer {
background: var(--dark-color);
color: white;
padding: 1rem 2rem;
display: flex;
justify-content: space-between;
align-items: center;
font-size: 0.9rem;
}

.status {
display: flex;
align-items: center;
gap: 0.5rem;
}

.scan-notification {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: var(--secondary-color);
color: white;
padding: 1rem 2rem;
border-radius: var(--border-radius);
font-weight: 600;
font-size: 1.2rem;
z-index: 1000;
box-shadow: var(--shadow-lg);
display: none;
}

.scan-notification.warning {
background: var(--warning-color);
}

.scan-notification.error {
background: var(--accent-color);
}

.loading-spinner {
width: 20px;
height: 20px;
border: 2px solid #f3f4f6;
border-top: 2px solid var(--primary-color);
border-radius: 50%;
animation: spin 1s linear infinite;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

@media (max-width: 768px) {
.main-content {
padding: 1rem;
}

.app-header {
padding: 1rem;
}

.logo-section {
flex-direction: column;
text-align: center;
gap: 0.5rem;
}

.company-info h1 {
font-size: 1.5rem;
}

.metrics-grid {
grid-template-columns: 1fr;
}

.fardos-grid {
grid-template-columns: 1fr;
}

.camera-controls {
justify-content: center;
}

.brightness-slider, .contrast-slider {
width: 120px;
}
}
</style>
</head>
<body>
<div class="app-container">
<!-- Header profesional -->
<header class="app-header">
<div class="version">v2.2.0</div>
<div class="connection-status" id="connection-status"></div>
<div class="logo-section">
<div class="logo">üìã</div>
<div class="company-info">
<h1>KALAF SOFT</h1>
<p>Sistema Check List de Paquetes de Piso - Mejorado</p>
</div>
</div>
</header>

<main class="main-content">
<!-- Sistema de alertas -->
<div class="alert alert-error" id="alert-error"></div>
<div class="alert alert-success" id="alert-success"></div>
<div class="alert alert-warning" id="alert-warning"></div>

<!-- Configuraci√≥n del sistema -->
<div class="card">
<div class="card-header">
<i class="fas fa-cog"></i>
Configuraci√≥n del Sistema
</div>
<div class="card-body">
<div class="file-input-wrapper">
<input type="file" id="fileInput" class="file-input" accept=".xlsx, .xls" />
<label for="fileInput" class="file-input-label" id="file-label">
<i class="fas fa-upload"></i>
<span>Seleccionar Archivo Excel</span>
</label>
</div>
<button id="start-button" class="btn btn-danger" disabled>
<i class="fas fa-camera"></i>
<span>Activar Esc√°ner</span>
</button>
</div>
</div>

<!-- Dashboard de m√©tricas -->
<div class="card">
<div class="card-header">
<i class="fas fa-chart-bar"></i>
Panel de Control
</div>
<div class="card-body">
<div class="metrics-grid">
<div class="metric-card total">
<div class="metric-value" id="total-count">0</div>
<div class="metric-label">Total</div>
</div>
<div class="metric-card success">
<div class="metric-value" id="completed-count">0</div>
<div class="metric-label">Completados</div>
</div>
<div class="metric-card pending">
<div class="metric-value" id="pending-count">0</div>
<div class="metric-label">Pendientes</div>
</div>
</div>

<div class="progress-container">
<div class="progress-header">
<span class="progress-label">Progreso General</span>
<span class="progress-percentage" id="progress-percentage">0%</span>
</div>
<div class="progress-bar">
<div class="progress-fill" id="progress-fill"></div>
</div>
</div>
</div>
</div>

<!-- C√°mara del esc√°ner -->
<div class="card">
<div class="card-header">
<i class="fas fa-qrcode"></i>
Esc√°ner de C√≥digos de Barras - Optimizado para Poca Luz
</div>
<div class="card-body">
<!-- NUEVOS CONTROLES DE C√ÅMARA -->
<div class="camera-controls" id="camera-controls" style="display: none;">
<div class="brightness-control">
<label>Brillo:</label>
<input type="range" id="brightness-slider" class="brightness-slider" min="0.5" max="2" step="0.1" value="1">
<span id="brightness-value">100%</span>
</div>
<div class="contrast-control">
<label>Contraste:</label>
<input type="range" id="contrast-slider" class="contrast-slider" min="0.5" max="3" step="0.1" value="1">
<span id="contrast-value">100%</span>
</div>
<button id="torch-toggle" class="btn btn-warning torch-toggle" style="display: none;">
<i class="fas fa-lightbulb"></i>
<span>Flash</span>
</button>
<button id="auto-enhance" class="btn btn-success">
<i class="fas fa-magic"></i>
<span>Auto Mejorar</span>
</button>
</div>

<!-- Informaci√≥n de detecci√≥n -->
<div class="detection-info" id="detection-info">
<div class="detection-stats">
<div class="stat-item">
<div class="stat-value" id="detection-rate">0</div>
<div class="stat-label">Detecciones/min</div>
</div>
<div class="stat-item">
<div class="stat-value" id="light-level">?</div>
<div class="stat-label">Nivel de Luz</div>
</div>
<div class="stat-item">
<div class="stat-value" id="quality-score">?</div>
<div class="stat-label">Calidad</div>
</div>
</div>
</div>

<div class="camera-container" id="camera-container">
<div class="camera-placeholder" id="camera-placeholder">
<i class="fas fa-camera"></i>
<div>Presiona "Activar Esc√°ner" para comenzar</div>
<div style="font-size: 0.9rem; margin-top: 0.5rem; opacity: 0.7;">
Optimizado para detecci√≥n en poca luz
</div>
</div>
<div class="camera-overlay"></div>
</div>
</div>
</div>

<!-- Lista de paquetes -->
<div class="card">
<div class="card-header">
<i class="fas fa-list-check"></i>
Lista de Paquetes de Piso
<span class="loading-spinner" id="loading-spinner" style="display: none; margin-left: auto;"></span>
</div>
<div class="card-body">
<div class="fardos-grid" id="fardos-grid">
<div style="grid-column: 1 / -1; text-align: center; color: #9ca3af; padding: 40px 20px; font-size: 14px;">
<i class="fas fa-inbox" style="font-size: 48px; margin-bottom: 16px; display: block;"></i>
Carga un archivo Excel para mostrar los paquetes
</div>
</div>
</div>
</div>
</main>

<!-- Footer de la app -->
<footer class="app-footer">
<div class="status">
<i class="fas fa-shield-check"></i>
Sistema Activo - Modo Poca Luz
</div>
<div>¬© 2024 KALAF SOFT</div>
</footer>

<!-- Notificaci√≥n de escaneo -->
<div class="scan-notification" id="scan-notification"></div>
</div>

<script>
// Variables del sistema
let fardos = [];
let isQuaggaStarted = false;
let systemReady = false;
let currentTrack = null;
let detectionStats = {
    detections: 0,
    lastDetectionTime: 0,
    lightLevel: 'unknown',
    qualityScore: 'unknown'
};

// Referencias a elementos DOM
const elements = {
fileInput: document.getElementById("fileInput"),
fileLabel: document.getElementById("file-label"),
startButton: document.getElementById("start-button"),
cameraContainer: document.getElementById("camera-container"),
cameraPlaceholder: document.getElementById("camera-placeholder"),
fardosGrid: document.getElementById("fardos-grid"),
scanNotification: document.getElementById("scan-notification"),
connectionStatus: document.getElementById("connection-status"),
loadingSpinner: document.getElementById("loading-spinner"),

// Contadores
totalCount: document.getElementById("total-count"),
completedCount: document.getElementById("completed-count"),
pendingCount: document.getElementById("pending-count"),
progressFill: document.getElementById("progress-fill"),
progressPercentage: document.getElementById("progress-percentage"),

// Alertas
alertError: document.getElementById("alert-error"),
alertSuccess: document.getElementById("alert-success"),
alertWarning: document.getElementById("alert-warning"),

// NUEVOS CONTROLES
cameraControls: document.getElementById("camera-controls"),
brightnessSlider: document.getElementById("brightness-slider"),
contrastSlider: document.getElementById("contrast-slider"),
brightnessValue: document.getElementById("brightness-value"),
contrastValue: document.getElementById("contrast-value"),
torchToggle: document.getElementById("torch-toggle"),
autoEnhance: document.getElementById("auto-enhance"),
detectionInfo: document.getElementById("detection-info"),
detectionRate: document.getElementById("detection-rate"),
lightLevel: document.getElementById("light-level"),
qualityScore: document.getElementById("quality-score")
};

// Sistema de sonido mejorado - SOLO MP3, SIN FALLBACK
class SoundSystem {
    static init() {
        this.audioLoaded = false;
        this.audioElement = null;
        this.userInteracted = false;
        
        console.log('üéµ Inicializando sistema de audio - SOLO MP3');
        
        // Detectar primera interacci√≥n del usuario
        this.setupUserInteraction();
        
        // Crear m√∫ltiples instancias para mejor compatibilidad
        this.createAudioInstances();
        
        // Intentar cargar de diferentes maneras
        this.tryLoadAudio();
    }
    
    static setupUserInteraction() {
        // Detectar cuando el usuario hace clic en cualquier parte
        const enableAudio = () => {
            if (!this.userInteracted) {
                this.userInteracted = true;
                console.log('‚úÖ Interacci√≥n del usuario detectada - Audio habilitado');
                
                // Crear contexto de audio si es necesario
                if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    if (!this.audioContext) {
                        this.audioContext = new AudioCtx();
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume();
                        }
                    }
                }
                
                // Pre-cargar el audio despu√©s de la interacci√≥n
                if (this.beepAudio && this.audioLoaded) {
                    this.beepAudio.load();
                }
            }
        };
        
        // Escuchar m√∫ltiples eventos de interacci√≥n
        ['click', 'touchstart', 'keydown'].forEach(event => {
            document.addEventListener(event, enableAudio, { once: true });
        });
    }
    
    static createAudioInstances() {
        // Crear el elemento de audio principal
        this.beepAudio = new Audio();
        this.beepAudio.preload = 'auto';
        this.beepAudio.volume = 0.8;
        
        // Rutas para GitHub y local
        const possiblePaths = [
            // Para GitHub Pages y repositorio
            './store-scanner-beep-90395.mp3',
            'store-scanner-beep-90395.mp3',
            '/store-scanner-beep-90395.mp3',
            // Para acceso directo en GitHub (raw)
            `${window.location.origin}${window.location.pathname.replace('index.html', '')}store-scanner-beep-90395.mp3`,
            // Ruta relativa m√°s espec√≠fica
            `${window.location.href.replace(/\/[^\/]*$/, '')}/store-scanner-beep-90395.mp3`
        ];
        
        console.log('üîç Rutas a probar:', possiblePaths);
        
        this.audioInstances = possiblePaths.map(path => {
            const audio = new Audio(path);
            audio.preload = 'auto';
            audio.volume = 0.8;
            audio.crossOrigin = "anonymous"; // Para GitHub
            return { audio, path };
        });
    }
    
    static tryLoadAudio() {
        console.log('üîÑ Intentando cargar archivo de audio...');
        
        // Probar cada instancia
        this.audioInstances.forEach((instance, index) => {
            const { audio, path } = instance;
            
            audio.addEventListener('loadeddata', () => {
                if (!this.audioLoaded) {
                    console.log(`‚úÖ Audio cargado exitosamente desde: ${path}`);
                    this.beepAudio = audio;
                    this.audioLoaded = true;
                    this.audioElement = audio;
                }
            });
            
            audio.addEventListener('canplaythrough', () => {
                if (!this.audioLoaded) {
                    console.log(`‚úÖ Audio listo para reproducir desde: ${path} - Duraci√≥n: ${audio.duration}s`);
                    this.beepAudio = audio;
                    this.audioLoaded = true;
                    this.audioElement = audio;
                }
            });
            
            audio.addEventListener('error', (e) => {
                console.log(`‚ùå Error cargando desde ${path}:`, e);
            });
            
            // Cargar el audio
            audio.load();
        });
        
        // Verificar carga despu√©s de 3 segundos
        setTimeout(() => {
            if (!this.audioLoaded) {
                console.log('‚ö†Ô∏è Reintentando carga de audio...');
                this.forceLoadAudio();
            }
        }, 3000);
        
        // Verificar nuevamente despu√©s de 6 segundos
        setTimeout(() => {
            if (!this.audioLoaded) {
                console.error('‚ùå ERROR CR√çTICO: No se pudo cargar el archivo de audio despu√©s de m√∫ltiples intentos');
                console.log('üìÅ Verifica que el archivo store-scanner-beep-90395.mp3 est√© en la misma carpeta que index.html');
                console.log('üåê Aseg√∫rate de estar ejecutando desde un servidor web, no file://');
            }
        }, 6000);
    }
    
    static forceLoadAudio() {
        console.log('üöÄ Forzando carga de audio...');
        
        // Crear una nueva instancia con evento de usuario
        const newAudio = new Audio('./store-scanner-beep-90395.mp3');
        newAudio.volume = 0.8;
        
        // Intentar cargar inmediatamente
        const loadPromise = newAudio.load();
        
        newAudio.addEventListener('loadeddata', () => {
            console.log('‚úÖ Audio forzado cargado exitosamente');
            this.beepAudio = newAudio;
            this.audioLoaded = true;
            this.audioElement = newAudio;
        });
        
        newAudio.addEventListener('error', (e) => {
            console.error('‚ùå Error en carga forzada:', e);
        });
    }
    
    static async playBeep() {
        console.log('üîä Reproduciendo beep - Estado cargado:', this.audioLoaded, '- Usuario interactu√≥:', this.userInteracted);
        
        // Verificar interacci√≥n del usuario
        if (!this.userInteracted) {
            console.log('‚ö†Ô∏è Esperando interacci√≥n del usuario para reproducir audio');
            return;
        }
        
        if (!this.audioLoaded || !this.beepAudio) {
            console.error('‚ùå AUDIO NO DISPONIBLE - El archivo MP3 no se ha cargado');
            console.log('üîß Intentando cargar audio de emergencia...');
            
            // Intentar crear y reproducir inmediatamente
            const emergencyAudio = new Audio('./store-scanner-beep-90395.mp3');
            emergencyAudio.volume = 0.8;
            
            try {
                const playPromise = emergencyAudio.play();
                if (playPromise !== undefined) {
                    await playPromise;
                    console.log('‚úÖ Audio de emergencia reproducido');
                    return;
                }
            } catch (e) {
                console.error('‚ùå Fall√≥ audio de emergencia:', e);
                return;
            }
        }
        
        try {
            console.log('üéµ Reproduciendo archivo MP3 principal');
            
            // Resetear el audio al inicio
            this.beepAudio.currentTime = 0;
            
            // Asegurar volumen
            this.beepAudio.volume = 0.8;
            
            // Reproducir
            const playPromise = this.beepAudio.play();
            
            if (playPromise !== undefined) {
                playPromise
                    .then(() => {
                        console.log('‚úÖ MP3 reproducido exitosamente');
                    })
                    .catch(async (e) => {
                        console.error('‚ùå Error reproduciendo MP3:', e);
                        console.log('üîÑ Reintentando reproducci√≥n...');
                        
                        // Reintentar una vez m√°s
                        try {
                            this.beepAudio.load();
                            await new Promise(resolve => setTimeout(resolve, 100));
                            this.beepAudio.currentTime = 0;
                            await this.beepAudio.play();
                            console.log('‚úÖ MP3 reproducido en reintento');
                        } catch (retryError) {
                            console.error('‚ùå Error en reintento:', retryError);
                        }
                    });
            } else {
                console.log('‚úÖ MP3 reproducido (navegador antiguo)');
            }
            
        } catch (e) {
            console.error('‚ùå Error cr√≠tico reproduciendo audio:', e);
        }
    }
    
    static playSuccessSound() {
        console.log('üéâ Reproduciendo sonido de √©xito (3 beeps)');
        
        // Reproducir 3 veces con intervalos
        this.playBeep();
        setTimeout(() => this.playBeep(), 200);
        setTimeout(() => this.playBeep(), 400);
    }
    
    static testAudio() {
        console.log('üß™ === DIAGN√ìSTICO DE AUDIO ===');
        console.log('Estado del sistema:');
        console.log('- audioLoaded:', this.audioLoaded);
        console.log('- userInteracted:', this.userInteracted);
        console.log('- beepAudio existe:', !!this.beepAudio);
        console.log('- readyState:', this.beepAudio?.readyState);
        console.log('- duration:', this.beepAudio?.duration);
        console.log('- src:', this.beepAudio?.src);
        console.log('- volume:', this.beepAudio?.volume);
        console.log('===============================');
        
        if (!this.userInteracted) {
            console.log('‚ö†Ô∏è NOTA: Necesitas hacer clic en la p√°gina primero para habilitar audio');
            console.log('üñ±Ô∏è Haz clic en cualquier parte de la p√°gina y luego ejecuta: SoundSystem.testAudio()');
        } else {
            console.log('üéµ Probando reproducci√≥n...');
            this.playBeep();
        }
    }
}

// NUEVO: Sistema de mejora de c√°mara para poca luz
class CameraEnhancementSystem {
    static init() {
        this.setupControls();
        this.brightness = 1;
        this.contrast = 1;
        this.torchSupported = false;
        this.torchEnabled = false;
        this.autoEnhanceEnabled = false;
        
        console.log('üì∏ Sistema de mejora de c√°mara inicializado');
    }
    
    static setupControls() {
        // Control de brillo
        elements.brightnessSlider.addEventListener('input', (e) => {
            this.brightness = parseFloat(e.target.value);
            this.updateCameraFilters();
            elements.brightnessValue.textContent = Math.round(this.brightness * 100) + '%';
        });
        
        // Control de contraste
        elements.contrastSlider.addEventListener('input', (e) => {
            this.contrast = parseFloat(e.target.value);
            this.updateCameraFilters();
            elements.contrastValue.textContent = Math.round(this.contrast * 100) + '%';
        });
        
        // Toggle de flash/torch
        elements.torchToggle.addEventListener('click', () => {
            this.toggleTorch();
        });
        
        // Auto mejora
        elements.autoEnhance.addEventListener('click', () => {
            this.autoEnhance();
        });
    }
    
    static updateCameraFilters() {
        const container = elements.cameraContainer;
        container.style.setProperty('--camera-brightness', this.brightness);
        container.style.setProperty('--camera-contrast', this.contrast);
        
        console.log(`üì∏ Filtros actualizados - Brillo: ${this.brightness}, Contraste: ${this.contrast}`);
    }
    
    static async enableTorch() {
        if (!currentTrack) return false;
        
        try {
            const capabilities = currentTrack.getCapabilities();
            if (capabilities.torch) {
                await currentTrack.applyConstraints({
                    advanced: [{ torch: true }]
                });
                this.torchEnabled = true;
                elements.torchToggle.innerHTML = '<i class="fas fa-lightbulb"></i><span>Flash ON</span>';
                elements.torchToggle.classList.remove('btn-warning');
                elements.torchToggle.classList.add('btn-success');
                console.log('üî¶ Flash activado');
                return true;
            }
        } catch (e) {
            console.error('‚ùå Error activando flash:', e);
        }
        return false;
    }
    
    static async disableTorch() {
        if (!currentTrack) return;
        
        try {
            await currentTrack.applyConstraints({
                advanced: [{ torch: false }]
            });
            this.torchEnabled = false;
            elements.torchToggle.innerHTML = '<i class="fas fa-lightbulb"></i><span>Flash</span>';
            elements.torchToggle.classList.remove('btn-success');
            elements.torchToggle.classList.add('btn-warning');
            console.log('üî¶ Flash desactivado');
        } catch (e) {
            console.error('‚ùå Error desactivando flash:', e);
        }
    }
    
    static async toggleTorch() {
        if (this.torchEnabled) {
            await this.disableTorch();
        } else {
            await this.enableTorch();
        }
    }
    
    static autoEnhance() {
        this.autoEnhanceEnabled = !this.autoEnhanceEnabled;
        
        if (this.autoEnhanceEnabled) {
            // Configuraci√≥n optimizada para poca luz
            this.brightness = 1.3;
            this.contrast = 1.5;
            
            elements.brightnessSlider.value = this.brightness;
            elements.contrastSlider.value = this.contrast;
            elements.brightnessValue.textContent = Math.round(this.brightness * 100) + '%';
            elements.contrastValue.textContent = Math.round(this.contrast * 100) + '%';
            
            // Aplicar clase especial
            elements.cameraContainer.classList.add('low-light');
            
            elements.autoEnhance.innerHTML = '<i class="fas fa-magic"></i><span>Auto ON</span>';
            elements.autoEnhance.classList.remove('btn-success');
            elements.autoEnhance.classList.add('btn-warning');
            
            NotificationSystem.show('success', '‚ú® Modo poca luz activado - Mejor detecci√≥n en ambientes oscuros', 3000);
        } else {
            // Restaurar valores normales
            this.brightness = 1;
            this.contrast = 1;
            
            elements.brightnessSlider.value = this.brightness;
            elements.contrastSlider.value = this.contrast;
            elements.brightnessValue.textContent = '100%';
            elements.contrastValue.textContent = '100%';
            
            elements.cameraContainer.classList.remove('low-light');
            
            elements.autoEnhance.innerHTML = '<i class="fas fa-magic"></i><span>Auto Mejorar</span>';
            elements.autoEnhance.classList.remove('btn-warning');
            elements.autoEnhance.classList.add('btn-success');
        }
        
        this.updateCameraFilters();
    }
    
    static checkTorchSupport() {
        if (!currentTrack) return false;
        
        try {
            const capabilities = currentTrack.getCapabilities();
            this.torchSupported = !!capabilities.torch;
            
            if (this.torchSupported) {
                elements.torchToggle.style.display = 'block';
                console.log('üî¶ Flash soportado por el dispositivo');
            } else {
                elements.torchToggle.style.display = 'none';
                console.log('‚ùå Flash no soportado por el dispositivo');
            }
            
            return this.torchSupported;
        } catch (e) {
            console.error('Error verificando soporte de flash:', e);
            return false;
        }
    }
    
    static updateDetectionStats(lightLevel, qualityScore) {
        detectionStats.lightLevel = lightLevel;
        detectionStats.qualityScore = qualityScore;
        
        elements.lightLevel.textContent = lightLevel;
        elements.qualityScore.textContent = qualityScore;
        
        // Auto-activar modo poca luz si la iluminaci√≥n es baja
        if (lightLevel === 'Baja' && !this.autoEnhanceEnabled) {
            console.log('üí° Luz baja detectada - Activando mejoras autom√°ticamente');
            setTimeout(() => this.autoEnhance(), 1000);
        }
    }
}

// Sistema de notificaciones
class NotificationSystem {
    static show(type, message, duration = 5000) {
        const alert = elements[`alert${type.charAt(0).toUpperCase() + type.slice(1)}`];
        if (!alert) return;

        alert.textContent = message;
        alert.style.display = 'block';

        setTimeout(() => {
            alert.style.display = 'none';
        }, duration);

        // Ocultar otras alertas
        ['error', 'success', 'warning'].forEach(t => {
            if (t !== type) {
                elements[`alert${t.charAt(0).toUpperCase() + t.slice(1)}`].style.display = 'none';
            }
        });
    }

    static hide() {
        ['error', 'success', 'warning'].forEach(type => {
            elements[`alert${type.charAt(0).toUpperCase() + type.slice(1)}`].style.display = 'none';
        });
    }
}

// Sistema de m√©tricas
class MetricsSystem {
    static update() {
        const total = fardos.length;
        const completed = fardos.filter(f => f.revisado).length;
        const pending = total - completed;
        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

        elements.totalCount.textContent = total;
        elements.completedCount.textContent = completed;
        elements.pendingCount.textContent = pending;
        elements.progressFill.style.width = `${percentage}%`;
        elements.progressPercentage.textContent = `${percentage}%`;

        // Actualizar estado de conexi√≥n
        elements.connectionStatus.className = systemReady ? 'connection-status' : 'connection-status offline';

        // Actualizar tasa de detecci√≥n
        this.updateDetectionRate();

        // Verificar completado
        if (total > 0 && completed === total) {
            NotificationSystem.show('success', `üéâ ¬°Excelente! Todos los ${total} paquetes han sido procesados correctamente.`);
            this.triggerCompletionEffects();
        }
    }

    static updateDetectionRate() {
        const now = Date.now();
        const oneMinute = 60000;
        
        // Calcular detecciones por minuto
        if (detectionStats.lastDetectionTime > 0) {
            const timeDiff = now - detectionStats.lastDetectionTime;
            if (timeDiff < oneMinute) {
                const rate = Math.round((detectionStats.detections / timeDiff) * oneMinute);
                elements.detectionRate.textContent = rate;
            }
        }
    }

    static triggerCompletionEffects() {
        // Vibraci√≥n de √©xito
        if ('vibrate' in navigator) {
            navigator.vibrate([200, 100, 200, 100, 200]);
        }

        // Sonido de √©xito
        SoundSystem.playSuccessSound();

        // Efecto visual en la barra de progreso
        elements.progressFill.style.background = 'linear-gradient(90deg, #10b981 0%, #34d399 50%, #10b981 100%)';
        elements.progressFill.style.boxShadow = '0 0 20px rgba(16, 185, 129, 0.5)';
    }
}

// Sistema de archivos
class FileSystem {
    static init() {
        elements.fileInput.addEventListener('change', this.handleFileChange.bind(this));
    }

    static handleFileChange(event) {
        const file = event.target.files[0];
        const label = elements.fileLabel;

        if (!file) {
            this.resetFileInput();
            return;
        }

        // Actualizar UI del input
        label.classList.add('has-file');
        label.innerHTML = `<i class="fas fa-file-excel"></i><span>${file.name}</span>`;

        // Mostrar loading
        elements.loadingSpinner.style.display = 'block';
        NotificationSystem.show('warning', 'Procesando archivo Excel...');

        // Procesar archivo
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheet = workbook.Sheets["Packing List"];

                if (!sheet) {
                    throw new Error('La hoja "Packing List" no fue encontrada en el archivo');
                }

                const rawData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                this.procesarDatos(rawData);

            } catch (error) {
                console.error('Error al procesar archivo:', error);
                NotificationSystem.show('error', `‚ùå Error: ${error.message}`);
                this.resetFileInput();
            } finally {
                elements.loadingSpinner.style.display = 'none';
            }
        };

        reader.readAsArrayBuffer(file);
    }

    static resetFileInput() {
        const label = elements.fileLabel;
        label.classList.remove('has-file');
        label.innerHTML = '<i class="fas fa-upload"></i><span>Seleccionar Archivo Excel</span>';
        elements.fileInput.value = '';
        elements.startButton.disabled = true;
        systemReady = false;
        MetricsSystem.update();
    }

    static procesarDatos(rawData) {
        const fardosUnicos = new Set();

        // Extraer paquetes √∫nicos del archivo Excel
        for (let i = 12; i < rawData.length; i++) {
            const fila = rawData[i];
            if (fila && fila[1]) {
                fardosUnicos.add(fila[1].toString().trim());
            }
        }

        // Convertir a array de objetos
        fardos = Array.from(fardosUnicos).map((paquete) => ({
            paquete: paquete,
            revisado: false,
            timestamp: null
        }));

        if (fardos.length > 0) {
            NotificationSystem.show('success', `‚úÖ Se cargaron ${fardos.length} paquetes correctamente.`);
            elements.startButton.disabled = false;
            systemReady = true;
            this.renderFardosList();
        } else {
            NotificationSystem.show('error', '‚ùå No se encontraron paquetes v√°lidos en el archivo.');
            systemReady = false;
        }

        MetricsSystem.update();
    }

    static renderFardosList() {
        const grid = elements.fardosGrid;
        grid.innerHTML = '';

        fardos.forEach((fardo, index) => {
            const item = document.createElement('div');
            item.className = 'fardo-item';
            item.textContent = fardo.paquete;
            item.id = `fardo-${index}`;

            if (fardo.revisado) {
                item.classList.add('completed');
            }

            grid.appendChild(item);
        });
    }
}

// Sistema de c√°mara y esc√°ner mejorado
class ScannerSystem {
    static init() {
        elements.startButton.addEventListener('click', this.handleStartScanner.bind(this));
    }

    static handleStartScanner() {
        if (!systemReady) {
            NotificationSystem.show('warning', '‚ö†Ô∏è Primero debe cargar un archivo Excel con los paquetes.');
            return;
        }

        if (!isQuaggaStarted) {
            NotificationSystem.hide();
            this.startQuagga();
        } else {
            // Detener esc√°ner si ya est√° iniciado
            this.stopScanner();
        }
    }

    static stopScanner() {
        Quagga.stop();
        isQuaggaStarted = false;
        
        // Limpiar track de c√°mara
        if (currentTrack) {
            currentTrack.stop();
            currentTrack = null;
        }
        
        elements.startButton.innerHTML = '<i class="fas fa-camera"></i><span>Activar Esc√°ner</span>';
        elements.startButton.className = "btn btn-danger";
        elements.cameraPlaceholder.style.display = "block";
        elements.cameraControls.style.display = "none";
        elements.detectionInfo.style.display = "none";
        
        // Desactivar torch si est√° activado
        if (CameraEnhancementSystem.torchEnabled) {
            CameraEnhancementSystem.disableTorch();
        }
    }

    static startQuagga() {
        // Configuraci√≥n mejorada para mejor detecci√≥n en poca luz
        Quagga.init({
            inputStream: {
                name: "Live",
                type: "LiveStream",
                target: elements.cameraContainer,
                constraints: {
                    width: { min: 640, ideal: 1920, max: 1920 },
                    height: { min: 480, ideal: 1080, max: 1080 },
                    facingMode: "environment",
                    // NUEVAS CONFIGURACIONES PARA POCA LUZ
                    advanced: [
                        { exposureMode: "manual" },
                        { whiteBalanceMode: "manual" },
                        { focusMode: "continuous" },
                        { brightness: { ideal: 0.7 } },
                        { contrast: { ideal: 1.4 } },
                        { saturation: { ideal: 1.2 } }
                    ]
                }
            },
            decoder: {
                readers: [
                    "code_128_reader", 
                    "ean_reader", 
                    "ean_8_reader",
                    "code_39_reader",
                    "code_39_vin_reader",
                    "codabar_reader",
                    "upc_reader",
                    "upc_e_reader",
                    // NUEVOS LECTORES PARA MEJOR DETECCI√ìN
                    "i2of5_reader",
                    "2of5_reader"
                ]
            },
            locator: {
                patchSize: "large", // Aumentado para mejor detecci√≥n
                halfSample: false   // Desactivado para mejor calidad
            },
            numOfWorkers: navigator.hardwareConcurrency ? Math.min(navigator.hardwareConcurrency, 8) : 4,
            locate: true,
            frequency: 15, // Aumentado para m√°s intentos por segundo
            // NUEVAS CONFIGURACIONES
            debug: {
                drawBoundingBox: true,
                showFrequency: true,
                drawScanline: true,
                showPattern: true
            }
        }, (err) => {
            if (err) {
                console.error("Error al iniciar Quagga:", err);
                NotificationSystem.show('error', '‚ùå Error al acceder a la c√°mara. Verifique los permisos.');
                elements.cameraPlaceholder.style.display = "block";
                return;
            }

            this.setupCamera();
        });
    }

    static setupCamera() {
        elements.cameraPlaceholder.style.display = "none";
        elements.cameraControls.style.display = "flex";
        elements.detectionInfo.style.display = "block";

        const video = elements.cameraContainer.querySelector("video");
        const canvas = elements.cameraContainer.querySelector("canvas");

        if (video) {
            video.style.display = "block";
            video.style.width = "100%";
            video.style.height = "100%";
            video.style.objectFit = "cover";
            
            // Obtener el track de video para controles avanzados
            if (video.srcObject) {
                currentTrack = video.srcObject.getVideoTracks()[0];
                CameraEnhancementSystem.checkTorchSupport();
                
                // Aplicar configuraciones iniciales de la c√°mara
                this.applyCameraSettings();
            }
        }
        
        if (canvas) {
            canvas.style.display = "block";
            canvas.style.position = "absolute";
            canvas.style.top = "0";
            canvas.style.left = "0";
            canvas.style.width = "100%";
            canvas.style.height = "100%";
        }

        Quagga.start();
        isQuaggaStarted = true;

        elements.startButton.innerHTML = '<i class="fas fa-stop"></i><span>Detener Esc√°ner</span>';
        elements.startButton.className = "btn btn-success";

        NotificationSystem.show('success', '‚úÖ Esc√°ner optimizado activado. Mejor detecci√≥n en poca luz habilitada.');
        
        // Auto-activar mejoras si es necesario
        setTimeout(() => {
            CameraEnhancementSystem.autoEnhance();
        }, 2000);
    }

    static async applyCameraSettings() {
        if (!currentTrack) return;

        try {
            // Aplicar configuraciones optimizadas para poca luz
            await currentTrack.applyConstraints({
                advanced: [
                    { exposureCompensation: { ideal: 1.0 } },
                    { iso: { ideal: 800 } },
                    { brightness: { ideal: 0.6 } },
                    { contrast: { ideal: 1.5 } },
                    { saturation: { ideal: 1.1 } },
                    { sharpness: { ideal: 0.8 } }
                ]
            });
            console.log('üì∏ Configuraciones de c√°mara aplicadas para poca luz');
        } catch (e) {
            console.log('‚ö†Ô∏è Algunas configuraciones de c√°mara no son compatibles:', e.message);
        }
    }

    static showScanNotification(message, type = 'success') {
        const notification = elements.scanNotification;
        notification.textContent = message;
        notification.className = `scan-notification ${type}`;
        notification.style.display = 'block';

        setTimeout(() => {
            notification.style.display = 'none';
        }, type === 'warning' ? 1500 : 2000);
    }

    static processBarcodeDetection(code) {
        const cleanCode = code.trim();
        console.log('C√≥digo detectado:', cleanCode);

        // Actualizar estad√≠sticas de detecci√≥n
        detectionStats.detections++;
        detectionStats.lastDetectionTime = Date.now();

        // Buscar el paquete en la lista
        const fardoIndex = fardos.findIndex(f => f.paquete === cleanCode);

        if (fardoIndex !== -1) {
            const fardo = fardos[fardoIndex];

            if (!fardo.revisado) {
                // Marcar como completado
                fardo.revisado = true;
                fardo.timestamp = new Date();

                // Actualizar UI
                const fardoElement = document.getElementById(`fardo-${fardoIndex}`);
                if (fardoElement) {
                    fardoElement.classList.add('completed');
                }

                // Efectos de √©xito
                SoundSystem.playBeep();
                this.showScanNotification(`‚úÖ Paquete ${cleanCode} registrado correctamente`, 'success');

                // Vibraci√≥n
                if ('vibrate' in navigator) {
                    navigator.vibrate([100]);
                }

                // Actualizar m√©tricas
                MetricsSystem.update();

            } else {
                // Ya fue escaneado
                SoundSystem.playBeep();
                this.showScanNotification(`‚ö†Ô∏è Paquete ${cleanCode} ya fue registrado`, 'warning');
            }
        } else {
            // Paquete no encontrado
            this.showScanNotification(`‚ùå Paquete ${cleanCode} no est√° en la lista`, 'error');
        }
    }
}

// Variables para evitar detecciones m√∫ltiples
let lastDetectedCode = null;
let lastDetectedTime = 0;
const DETECTION_COOLDOWN = 1500; // Reducido para mejor respuesta

// Evento de detecci√≥n de c√≥digo de barras MEJORADO
Quagga.onDetected(function(result) {
    const code = result.codeResult.code;
    const currentTime = Date.now();

    // Evitar detecciones repetidas
    if (code === lastDetectedCode && (currentTime - lastDetectedTime) < DETECTION_COOLDOWN) {
        return;
    }

    // NUEVA VALIDACI√ìN DE CALIDAD
    const confidence = result.codeResult.confidence || 0;
    if (confidence < 60) { // Filtrar detecciones de baja confianza
        console.log(`üîç C√≥digo descartado por baja confianza: ${code} (${confidence})`);
        return;
    }

    lastDetectedCode = code;
    lastDetectedTime = currentTime;

    console.log(`üéØ C√≥digo v√°lido detectado: ${code} (Confianza: ${confidence})`);

    // Procesar el c√≥digo detectado
    ScannerSystem.processBarcodeDetection(code);
});

// Dibujar overlay en la c√°mara MEJORADO
Quagga.onProcessed(function (result) {
    const drawingCtx = Quagga.canvas.ctx.overlay;
    const drawingCanvas = Quagga.canvas.dom.overlay;

    if (!drawingCtx || !drawingCanvas) return;

    drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

    // AN√ÅLISIS DE ILUMINACI√ìN
    const imageData = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
    const brightness = this.analyzeBrightness(imageData);
    const lightLevel = brightness > 120 ? 'Alta' : brightness > 80 ? 'Media' : 'Baja';
    const quality = result ? (result.codeResult ? 'Buena' : 'Regular') : 'Buscando...';
    
    // Actualizar estad√≠sticas
    CameraEnhancementSystem.updateDetectionStats(lightLevel, quality);

    // Dibujar cuadro de escaneo adaptativo seg√∫n la luz
    const rectWidth = drawingCanvas.width * 0.75;
    const rectHeight = drawingCanvas.height * 0.35;
    const rectX = (drawingCanvas.width - rectWidth) / 2;
    const rectY = (drawingCanvas.height - rectHeight) / 2;

    // Color del cuadro seg√∫n la iluminaci√≥n
    let strokeColor = '#10b981'; // Verde por defecto
    let fillColor = 'rgba(16, 185, 129, 0.1)';
    
    if (lightLevel === 'Baja') {
        strokeColor = '#f59e0b'; // Amarillo para poca luz
        fillColor = 'rgba(245, 158, 11, 0.15)';
    } else if (lightLevel === 'Media') {
        strokeColor = '#3b82f6'; // Azul para luz media
        fillColor = 'rgba(59, 130, 246, 0.1)';
    }

    // Cuadro principal
    drawingCtx.lineWidth = 3;
    drawingCtx.strokeStyle = strokeColor;
    drawingCtx.fillStyle = fillColor;
    drawingCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
    drawingCtx.strokeRect(rectX, rectY, rectWidth, rectHeight);

    // Esquinas del cuadro de escaneo mejoradas
    const cornerLength = 25;
    const cornerThickness = 5;
    drawingCtx.lineWidth = cornerThickness;
    drawingCtx.strokeStyle = '#ffffff';

    // Esquinas con sombra
    drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    drawingCtx.shadowBlur = 2;
    drawingCtx.shadowOffsetX = 1;
    drawingCtx.shadowOffsetY = 1;

    // Esquina superior izquierda
    drawingCtx.beginPath();
    drawingCtx.moveTo(rectX, rectY + cornerLength);
    drawingCtx.lineTo(rectX, rectY);
    drawingCtx.lineTo(rectX + cornerLength, rectY);
    drawingCtx.stroke();

    // Esquina superior derecha
    drawingCtx.beginPath();
    drawingCtx.moveTo(rectX + rectWidth - cornerLength, rectY);
    drawingCtx.lineTo(rectX + rectWidth, rectY);
    drawingCtx.lineTo(rectX + rectWidth, rectY + cornerLength);
    drawingCtx.stroke();

    // Esquina inferior izquierda
    drawingCtx.beginPath();
    drawingCtx.moveTo(rectX, rectY + rectHeight - cornerLength);
    drawingCtx.lineTo(rectX, rectY + rectHeight);
    drawingCtx.lineTo(rectX + cornerLength, rectY + rectHeight);
    drawingCtx.stroke();

    // Esquina inferior derecha
    drawingCtx.beginPath();
    drawingCtx.moveTo(rectX + rectWidth - cornerLength, rectY + rectHeight);
    drawingCtx.lineTo(rectX + rectWidth, rectY + rectHeight);
    drawingCtx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerLength);
    drawingCtx.stroke();

    // Resetear sombra
    drawingCtx.shadowColor = 'transparent';
    drawingCtx.shadowBlur = 0;
    drawingCtx.shadowOffsetX = 0;
    drawingCtx.shadowOffsetY = 0;

    // Texto de instrucci√≥n adaptativo
    drawingCtx.fillStyle = '#ffffff';
    drawingCtx.font = 'bold 16px Arial';
    drawingCtx.textAlign = 'center';
    drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    drawingCtx.shadowBlur = 3;
    
    let instructionText = 'Coloque el c√≥digo de barras dentro del marco';
    if (lightLevel === 'Baja') {
        instructionText = 'üí° Poca luz detectada - Use el flash o mueva a mejor iluminaci√≥n';
    }
    
    drawingCtx.fillText(instructionText, drawingCanvas.width / 2, rectY - 15);

    // Indicador de estado en tiempo real
    drawingCtx.font = '14px Arial';
    drawingCtx.fillStyle = strokeColor;
    drawingCtx.fillText(`Luz: ${lightLevel} | Calidad: ${quality}`, 
                       drawingCanvas.width / 2, rectY + rectHeight + 25);

    // L√≠nea de escaneo animada
    const scanLineY = rectY + (rectHeight / 2) + Math.sin(Date.now() / 200) * 10;
    drawingCtx.beginPath();
    drawingCtx.moveTo(rectX, scanLineY);
    drawingCtx.lineTo(rectX + rectWidth, scanLineY);
    drawingCtx.lineWidth = 2;
    drawingCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    drawingCtx.stroke();

    // Resetear sombra
    drawingCtx.shadowColor = 'transparent';
    drawingCtx.shadowBlur = 0;

    // Dibujar c√≥digos detectados con mejor visualizaci√≥n
    if (result) {
        if (result.boxes) {
            result.boxes
                .filter((box) => box !== result.box)
                .forEach((box) => {
                    drawingCtx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                    drawingCtx.lineWidth = 2;
                    drawingCtx.beginPath();
                    box.forEach((point, index) => {
                        if (index === 0) {
                            drawingCtx.moveTo(point[0], point[1]);
                        } else {
                            drawingCtx.lineTo(point[0], point[1]);
                        }
                    });
                    drawingCtx.closePath();
                    drawingCtx.stroke();
                });
        }

        if (result.box) {
            // C√≥digo detectado con animaci√≥n
            const pulseIntensity = Math.sin(Date.now() / 100) * 0.3 + 0.7;
            drawingCtx.strokeStyle = `rgba(0, 255, 0, ${pulseIntensity})`;
            drawingCtx.lineWidth = 4;
            drawingCtx.beginPath();
            result.box.forEach((point, index) => {
                if (index === 0) {
                    drawingCtx.moveTo(point[0], point[1]);
                } else {
                    drawingCtx.lineTo(point[0], point[1]);
                }
            });
            drawingCtx.closePath();
            drawingCtx.stroke();

            // Sombra del c√≥digo detectado
            drawingCtx.strokeStyle = "rgba(0, 255, 0, 0.3)";
            drawingCtx.lineWidth = 8;
            drawingCtx.stroke();
        }

        if (result.codeResult && result.codeResult.code) {
            // Mostrar c√≥digo detectado con mejor estilo
            const confidence = result.codeResult.confidence || 0;
            drawingCtx.fillStyle = confidence > 80 ? "#00ff00" : "#ffff00";
            drawingCtx.font = "bold 18px Arial";
            drawingCtx.textAlign = "left";
            drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.8)';
            drawingCtx.shadowBlur = 3;
            drawingCtx.fillText(`${result.codeResult.code} (${Math.round(confidence)}%)`, 15, 35);
            drawingCtx.shadowColor = 'transparent';
            drawingCtx.shadowBlur = 0;
        }
    }
});

// Funci√≥n para analizar brillo de la imagen
function analyzeBrightness(imageData) {
    const data = imageData.data;
    let totalBrightness = 0;
    const pixelCount = data.length / 4;
    
    for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        // Calcular luminancia usando la f√≥rmula est√°ndar
        const brightness = 0.299 * r + 0.587 * g + 0.114 * b;
        totalBrightness += brightness;
    }
    
    return totalBrightness / pixelCount;
}

// Inicializaci√≥n del sistema MEJORADA
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Inicializando KALAF SOFT System v2.2.0 - Optimizado para poca luz...');
        
    // Verificar disponibilidad de APIs necesarias
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        NotificationSystem.show('error', '‚ùå Tu navegador no soporta acceso a c√°mara. Usa Chrome o Firefox moderno.');
        return;
    }

    // Inicializar m√≥dulos
    SoundSystem.init();
    CameraEnhancementSystem.init(); // NUEVO
    FileSystem.init();
    ScannerSystem.init();
    MetricsSystem.update();

    console.log('‚úÖ Sistema inicializado correctamente con mejoras para poca luz');
    NotificationSystem.show('success', '‚úÖ Sistema KALAF SOFT v2.2.0 listo. Optimizado para detecci√≥n en poca luz.', 4000);
});

// Manejo de errores globales
window.addEventListener('error', function(e) {
    console.error('Error global:', e.error);
    NotificationSystem.show('error', '‚ùå Se produjo un error en el sistema. Recarga la p√°gina si persiste.');
});

// Manejo de permisos de c√°mara mejorado
navigator.permissions?.query({name: 'camera'}).then(function(result) {
    console.log('Estado de permisos de c√°mara:', result.state);
    if (result.state === 'denied') {
        NotificationSystem.show('warning', '‚ö†Ô∏è Los permisos de c√°mara est√°n denegados. Habil√≠talos en la configuraci√≥n del navegador.');
    }
    
    result.onchange = function() {
        if (result.state === 'granted') {
            NotificationSystem.show('success', '‚úÖ Permisos de c√°mara concedidos. Ya puedes usar el esc√°ner.');
        }
    };
});

// Detecci√≥n de cambios en la conectividad
window.addEventListener('online', function() {
    console.log('üåê Conexi√≥n restaurada');
    elements.connectionStatus.className = 'connection-status';
});

window.addEventListener('offline', function() {
    console.log('üö´ Sin conexi√≥n a internet');
    elements.connectionStatus.className = 'connection-status offline';
});

// Optimizaciones de rendimiento mejoradas
if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
        // Pre-cargar recursos cuando el sistema est√© inactivo
        console.log('üîß Aplicando optimizaciones de rendimiento...');
        
        // Optimizar detecci√≥n de c√≥digos
        if (typeof Quagga !== 'undefined') {
            Quagga.ImageWrapper.prototype.invert = function() {
                // Invertir imagen para mejor detecci√≥n en poca luz
                const data = this.data;
                for (let i = 0; i < data.length; i++) {
                    data[i] = 255 - data[i];
                }
            };
        }
    });
}

// Prevenir zoom en dispositivos m√≥viles
document.addEventListener('touchstart', function(event) {
    if (event.touches.length > 1) {
        event.preventDefault();
    }
});

let lastTouchEnd = 0;
document.addEventListener('touchend', function(event) {
    const now = (new Date()).getTime();
    if (now - lastTouchEnd <= 300) {
        event.preventDefault();
    }
    lastTouchEnd = now;
}, false);

// Atajos de teclado para desarrolladores
document.addEventListener('keydown', function(e) {
    // Ctrl + Shift + D = Activar/Desactivar debug
    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
        console.log('üîß Modo debug activado');
        SoundSystem.testAudio();
        e.preventDefault();
    }
    
    // Ctrl + Shift + L = Toggle modo poca luz
    if (e.ctrlKey && e.shiftKey && e.key === 'L') {
        console.log('üí° Toggle modo poca luz');
        if (isQuaggaStarted) {
            CameraEnhancementSystem.autoEnhance();
        }
        e.preventDefault();
    }
    
    // Ctrl + Shift + F = Toggle flash
    if (e.ctrlKey && e.shiftKey && e.key === 'F') {
        console.log('üî¶ Toggle flash');
        if (isQuaggaStarted && CameraEnhancementSystem.torchSupported) {
            CameraEnhancementSystem.toggleTorch();
        }
        e.preventDefault();
    }
});

// Funci√≥n de diagn√≥stico completo
window.diagnosticSystem = function() {
    console.log('üîç === DIAGN√ìSTICO COMPLETO DEL SISTEMA ===');
    console.log('Estado general:');
    console.log('- Sistema listo:', systemReady);
    console.log('- Esc√°ner activo:', isQuaggaStarted);
    console.log('- Paquetes cargados:', fardos.length);
    console.log('- Audio cargado:', SoundSystem.audioLoaded);
    console.log('- Usuario interactu√≥:', SoundSystem.userInteracted);
    console.log('- Flash soportado:', CameraEnhancementSystem.torchSupported);
    console.log('- Auto mejora activa:', CameraEnhancementSystem.autoEnhanceEnabled);
    console.log('Estad√≠sticas de detecci√≥n:');
    console.log('- Detecciones totales:', detectionStats.detections);
    console.log('- Nivel de luz:', detectionStats.lightLevel);
    console.log('- Calidad:', detectionStats.qualityScore);
    console.log('Configuraci√≥n de c√°mara:');
    console.log('- Brillo:', CameraEnhancementSystem.brightness);
    console.log('- Contraste:', CameraEnhancementSystem.contrast);
    console.log('- Flash activo:', CameraEnhancementSystem.torchEnabled);
    console.log('==========================================');
};

console.log('üí° Tip: Ejecuta diagnosticSystem() en la consola para un diagn√≥stico completo');
console.log('üéØ Sistema optimizado para detecci√≥n en poca luz - v2.2.0');
</script>
</body>
</html>
